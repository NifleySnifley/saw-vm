#TODO: add better string support
from csv import DictReader
from argparse import ArgumentParser

OPCODES = [opcode for opcode in DictReader(
    open("opcodes.csv", "r", encoding='utf-8'))]


def get_opcode_by_name(name: str):
    for i, opcode in enumerate(OPCODES):
        if opcode['opcode'].lower() == name.lower():
            return i
    raise SyntaxError("Cannot find opcode '%s'!" % name)


parser = ArgumentParser()
parser.add_argument("-i", "--input-file",
                    help="The .sawasm file to assemble.", default="main.sawasm")
parser.add_argument("-o", "--output-file",
                    help="The output file", default="main.saw")

args = parser.parse_args()

macros = {} # A dictionary of macros. This includes both user-defined macros and labels.

with open(args.input_file, "r", encoding='utf-8') as source_fp:
    with open(args.output_file, "wb") as fp:
        lines = [line.strip() for line in source_fp.readlines()]
        out = []

        for line in lines:
            offset = len(out)

            if line.startswith("#"):  # support for comments
                continue
            line = line.split("#")[0]

            if len(line.strip()) == 0:  # whitespace
                continue

            if line.startswith("0x"): # ignore offsets generated by the disassembler
                line = " ".join(line.split(" ")[1:])
            if line.startswith("%"): # handle macros
                if line.startswith("%define"):
                    macros["%" + line.split(" ")[1]] = int(line.split(" ")[2])
                    continue
                else:
                    macros[line.split(" ")[0]] = offset
                    line = " ".join(line.split(" ")[1:])

            spl = line.split(" ")

            opcode = spl[0]
            out.append(get_opcode_by_name(opcode))

            for arg in spl[1:]:
                if arg.startswith("\""):
                    out.append(len(arg) - 2)
                    for c in arg[1:-1]:
                        out.append(c.encode('utf-8')[0])
                elif arg.startswith("%"):
                    out.append(arg)
                else:
                    out.append(int(arg))

        def offset_label_substitution(byte):
            if str(byte).startswith("%"):
                if not str(byte) in macros:
                    print(f"ERROR: Macro '{byte}' is not defined!")
                    exit(0)
                return int(macros[str(byte)])
            return byte

        out = list(map(offset_label_substitution, out))

        fp.write(bytes(out))
